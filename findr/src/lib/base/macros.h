/* Copyright 2016-2018, 2020, 2021 Lingfei Wang
 * 
 * This file is part of Findr.
 * 
 * Findr is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Findr is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with Findr.  If not, see <http://www.gnu.org/licenses/>.
 */
// This file contains the macro definitions, such as cleanup macros

#ifndef _HEADER_LIB_MACROS_H_
#define _HEADER_LIB_MACROS_H_
#include "config.h"
#include <string.h>
#include "types.h"
#include "logger.h"

#define	ERRRETV(V,...)	{LOG(1,__VA_ARGS__) CLEANUP return V;}
#define	ERRRET(...)		ERRRETV(1,__VA_ARGS__)

#define AUTOALLOCHEADER _autoalloc_
#ifndef __STDC_NO_VLA__
/* Automatically allocate memory depending on size. For count<=countmax,
 * allocation is through stack. For count>countmax, allocation is through
 * heap.
 */

#define AUTOALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,SUFFIX) \
	TYPE AUTOALLOCHEADER##NAME[(COUNT)<=(COUNTMAX)?(COUNT):0];\
	TYPE * SUFFIX NAME;\
	if((COUNT)<=(COUNTMAX))NAME=AUTOALLOCHEADER##NAME;\
	else{if(COUNT) NAME=(TYPE*)malloc((COUNT)*(sizeof(TYPE)));\
		else NAME=0;}
#define AUTOCALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,SUFFIX) \
	TYPE AUTOALLOCHEADER##NAME[(COUNT)<=(COUNTMAX)?(COUNT):0];\
	TYPE * SUFFIX NAME;\
	if((COUNT)<=(COUNTMAX)){\
		NAME=AUTOALLOCHEADER##NAME;\
		memset(NAME,0,(COUNT)*sizeof(TYPE));}\
	else{if(COUNT) NAME=(TYPE*)calloc(COUNT,sizeof(TYPE));\
		else NAME=0;}

/* Automatically free memory depending on size. Does nothing if memory is on stack,
 * frees memory if is on heap.
 */
#define	AUTOFREE(NAME) if(sizeof(AUTOALLOCHEADER##NAME)==0)CLEANMEM(NAME)
#else
#define AUTOALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,SUFFIX) \
	TYPE * SUFFIX NAME=(TYPE*)malloc((COUNT)*sizeof(TYPE));
#define AUTOCALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,SUFFIX) \
	TYPE * SUFFIX NAME=(TYPE*)calloc(COUNT,sizeof(TYPE);
#define AUTOFREE(NAME) CLEANMEM(NAME)
#endif
#define AUTOALLOC(TYPE,NAME,COUNT,COUNTMAX) AUTOALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,)
#define AUTOCALLOC(TYPE,NAME,COUNT,COUNTMAX) AUTOCALLOCSUF(TYPE,NAME,COUNT,COUNTMAX,)


#define AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,BASETYPE,VECTYPE)	\
	AUTOALLOC(BASETYPE,_vec_##NAME,COUNT,COUNTMAX)\
	CONCATENATE2(VECTYPE,_view) _vecview_##NAME;\
	VECTYPE* NAME=0;\
	if(_vec_##NAME)\
	{\
		_vecview_##NAME=CONCATENATE2(VECTYPE,_view_array)(_vec_##NAME,COUNT);\
		NAME=&_vecview_##NAME.vector;\
	}
#define AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,BASETYPE,MATTYPE)	\
	AUTOALLOC(BASETYPE,_mat_##NAME,(COUNT1)*(COUNT2),COUNTMAX)\
	CONCATENATE2(VECTYPE,_view) _matview_##NAME;\
	MATTYPE* NAME=0;\
	if(_mat_##NAME)\
	{\
		_matview_##NAME=CONCATENATE2(MATTYPE,_view_array)(_mat_##NAME,COUNT1,COUNT2);\
		NAME=&_matview_##NAME.matrix;\
	}\

#define AUTOFREEVEC(NAME)	if(NAME){AUTOFREE(_vec_##NAME)NAME=0;}
#define AUTOFREEMAT(NAME)	if(NAME){AUTOFREE(_mat_##NAME)NAME=0;}

#define AUTOALLOCVECO(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,float,			VECTORO)
#define AUTOALLOCVECD(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,double,			VECTORD)
#define AUTOALLOCVECC(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,char,			VECTORC)
#define AUTOALLOCVECUC(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,unsigned char,	VECTORUC)
#define AUTOALLOCVECI(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,int,			VECTORI)
#define AUTOALLOCVECL(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,long,			VECTORL)
#define AUTOALLOCVECUL(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,unsigned long,	VECTORUL)
#define AUTOALLOCVECF(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,FTYPE,			VECTORF)
#define	AUTOALLOCVECG(NAME,COUNT,COUNTMAX)		AUTOALLOCVECTOR(NAME,COUNT,COUNTMAX,GTYPE,			VECTORG)
#define AUTOALLOCMATO(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,float,			MATRIXO)
#define AUTOALLOCMATD(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,double,			MATRIXD)
#define AUTOALLOCMATC(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,char,			MATRIXC)
#define AUTOALLOCMATUC(NAME,COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,unsigned char,	MATRIXUC)
#define AUTOALLOCMATI(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,int,			MATRIXI)
#define AUTOALLOCMATL(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,long,			MATRIXL)
#define AUTOALLOCMATUL(NAME,COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,unsigned long,	MATRIXUL)
#define AUTOALLOCMATF(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,FTYPE,			MATRIXF)
#define	AUTOALLOCMATG(NAME,	COUNT1,COUNT2,COUNTMAX)		AUTOALLOCMATRIX(NAME,COUNT1,COUNT2,COUNTMAX,GTYPE,			MATRIXG)

// Cleanup macros
#define	CLEANANY(X,F)	if(X){F(X);X=0;}
#define CLEANMEM(X)		CLEANANY(X,free)
#define CLEANVECO(X)	CLEANANY(X,VECTOROF(free))
#define CLEANVECD(X)	CLEANANY(X,VECTORDF(free))
#define CLEANVECC(X)	CLEANANY(X,VECTORCF(free))
#define CLEANVECUC(X)	CLEANANY(X,VECTORUCF(free))
#define CLEANVECI(X)	CLEANANY(X,VECTORIF(free))
#define CLEANVECL(X)	CLEANANY(X,VECTORLF(free))
#define CLEANVECUL(X)	CLEANANY(X,VECTORULF(free))
#define CLEANVECF(X)	CLEANANY(X,VECTORFF(free))
#define CLEANVECG(X)	CLEANANY(X,VECTORGF(free))

#define CLEANMATO(X)	CLEANANY(X,MATRIXOF(free))
#define CLEANMATD(X)	CLEANANY(X,MATRIXDF(free))
#define CLEANMATC(X)	CLEANANY(X,MATRIXCF(free))
#define CLEANMATUC(X)	CLEANANY(X,MATRIXUCF(free))
#define CLEANMATI(X)	CLEANANY(X,MATRIXIF(free))
#define CLEANMATL(X)	CLEANANY(X,MATRIXLF(free))
#define CLEANMATUL(X)	CLEANANY(X,MATRIXULF(free))
#define CLEANMATF(X)	CLEANANY(X,MATRIXFF(free))
#define CLEANMATG(X)	CLEANANY(X,MATRIXGF(free))

#define	CLEANPERM(X)	CLEANANY(X,gsl_permutation_free)
#define	CLEANHIST(X)	CLEANANY(X,gsl_histogram_free)
#define	CLEANFILE(X)	CLEANANY(X,fclose)
#define	CLEANMMATF(X,N)	if(X){for(i=0;i<N;i++)CLEANMATF(X[i])free(X);X=0;}
#define	CLEANMMATD(X,N)	if(X){for(i=0;i<N;i++)CLEANMATD(X[i])free(X);X=0;}
#define	CLEANMVECD(X,N)	if(X){for(i=0;i<N;i++)CLEANVECD(X[i])free(X);X=0;}
#define	CLEANMHIST(X,N)	if(X){for(i=0;i<N;i++)CLEANHIST(X[i])free(X);X=0;}
#define	CLEANAMHIST(X,N)	if(X){for(i=0;i<N;i++)CLEANHIST(X[i])AUTOFREE(X)}
#define	CLEANAMMATF(X,N)	if(X){for(i=0;i<N;i++)CLEANMATF(X[i])AUTOFREE(X)}


#define	MALLOCSIZE(X,N)	((X)=malloc((N)*sizeof(*(X))))
#define	CALLOCSIZE(X,N)	((X)=calloc((N),sizeof(*(X))))

#endif




























